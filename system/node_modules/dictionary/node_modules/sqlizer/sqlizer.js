'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;
	this.metaData = {};
	this.addMeta = function(name, data) {
		this.metaData[name] = data;
	}

	qtools.validateProperties({
		subject: args,
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'tables',
				optional: true
			}
		]
	});

	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};


	//LOCAL FUNCTIONS ====================================



	//METHODS AND PROPERTIES ====================================
	this.reset = function(tables) {
		this.tables = tables;
		self.indexes = {};
		self.workingTable = [];
		self.baseTableName = '';
		self.duplicates = {};
		this.summaryTables = {};
	}

	this.getSpecialTable = function(categoryName, tableName) {
		return this[categoryName][tableName];
	}

	this.addTable = function(tableName, inTable) {
		this.tables[tableName] = inTable;
	}

	this.removeDupes = function(tableName) {
		var outList = [],
			uniqueTokenList = {};
		for (var i = 0, len = this.tables[tableName].length; i < len; i++) {
			var element = this.tables[tableName][i],

				uniqueToken = qtools.hash(element);

			if (!uniqueTokenList[uniqueToken]) {
				uniqueTokenList[uniqueToken] = true;
				outList.push(element);
			} else {
				if (!this.duplicates[tableName]) {
					this.duplicates[tableName] = [];
				}
				this.duplicates[tableName].push(element);
			}

		}

		this.tables[tableName] = outList;
	}

	this.setBaseTable = function(tableName) {
		this.baseTableName = tableName;


		if (global.localEnvironment.testServer && !this.tables[tableName]) {
			qtools.message("SQLizer Invalid tableName: " + tableName + " does not exist");
		}
		if (global.localEnvironment.testServer) {
			qtools.message("SQLizer Base Table " + tableName + " has " + this.tables[tableName].length + " records");
		}

		for (var i = 0, len = this.tables[tableName].length; i < len; i++) {
			var element = this.tables[tableName][i];

			var recordObject = {};
			recordObject[tableName] = element;
			this.workingTable.push(recordObject);
		}
	}

	this.index = function(tableName, propertyName) {
		var newIndex = {},
			table = (tableName == 'workingTable') ? this.workingTable : this.tables[tableName];


		for (var i = 0, len = table.length; i < len; i++) {
			var element = table[i];
			var indexElementName = qtools.getSurePath(element, propertyName);

			if (typeof (newIndex[indexElementName]) == 'undefined') {
				newIndex[indexElementName] = [];
			}
			newIndex[indexElementName].push(element);

		}

		if (typeof (this.indexes[tableName]) == 'undefined') {
			this.indexes[tableName] = {};
		}
		this.indexes[tableName][propertyName] = newIndex;
	}


	this.indexWorkingTable = function(propertyName) {
		this.index('workingTable', propertyName);

	}

	this.summarize = function(summaryName, indexName, selector) {
		var indexTable = this.indexes.workingTable[indexName],
			summaryTable = [];

		for (var i in indexTable) {
			var element = indexTable[i];
			summaryTable.push(selector(element));
		}

		this.summaryTables[summaryName] = summaryTable;
	}

	this.leftJoin = function(linkColumn, targetTableName, targetLinkColumn) {

		var resultTable = [],
			leftCount = 0;

		for (var i = 0, len = this.workingTable.length; i < len; i++) {

			var newRecord = qtools.clone(this.workingTable[i]),
				linkingValue = this.workingTable[i][this.baseTableName][linkColumn];

			newRecord[targetTableName] = [];

			var targetTable = this.tables[targetTableName];

			for (var j = 0, len2 = targetTable.length; j < len2; j++) {
				var matchingRecord = qtools.clone(targetTable[j]);

				leftCount++;

				if (linkingValue == matchingRecord[targetLinkColumn]) {
					newRecord[targetTableName].push(matchingRecord);

				}

			}

			resultTable.push(newRecord);

		}

//console.log('leftCount=' + leftCount + '\n');
		this.workingTable = resultTable;
	}

	this.leftJoinOLD = function(linkColumn, targetTableName, targetLinkColumn) {
		if (!self.indexes[targetTableName] || !self.indexes[targetTableName][targetLinkColumn]) {
			self.index(targetTableName, targetLinkColumn);
		}

		self.index(this.baseTableName, targetLinkColumn);

		var index = this.indexes[targetTableName][targetLinkColumn],
			resultTable = [];

		for (var i = 0, len = this.workingTable.length; i < len; i++) {

			var linkingValue = this.workingTable[i][this.baseTableName][linkColumn];

			this.workingTable[i][targetTableName] = index[linkingValue];


			if (typeof (index[linkingValue]) == 'undefined') {
				var newRecord = {};
				newRecord = this.workingTable[i];
				newRecord[targetTableName] = {};
				resultTable.push(newRecord)
			} else {
				for (var j = 0, len2 = index[linkingValue].length; j < len2; j++) {
					var matchingRecords = index[linkingValue],
						newRecord = {};

					newRecord = qtools.clone(this.workingTable[i]);
					newRecord[targetTableName] = index[linkingValue][j];

					resultTable.push(newRecord);

				}
			}

		}

		this.workingTable = resultTable;
	}



	this.innerJoin = function(linkColumn, targetTableName, targetLinkColumn) {

		var outList = [],
			currInx;

		var innerCount = 0;

		for (var i = 0, len = this.workingTable.length; i < len; i++) {
			var element = this.workingTable[i][this.baseTableName][linkColumn];

			var targetTable = this.tables[targetTableName],
				newElement = [],
				someSuccess=false;
			for (var j = 0, len2 = targetTable.length; j < len2; j++) {


				innerCount++;
				if (typeof (targetLinkColumn) == 'function') {
					var matches = targetLinkColumn(this.workingTable[i][this.baseTableName], targetTable[j]);
				} else {
					var matches = (element == targetTable[j][targetLinkColumn]);
				}

				if (matches) {

					newElement.push(targetTable[j]);
					someSuccess=true;
				}
			}

			if (newElement && someSuccess) {
				outList.push(this.workingTable[i]);
				currInx = outList.length - 1;
				outList[currInx][targetTableName] = newElement;

			}

		}

//console.log('innerCount=' + innerCount + '\n');
		this.workingTable = outList;

	}

	this.mapColumns = function(map) {

		for (var i = 0, len = this.workingTable.length; i < len; i++) {
			var element = this.workingTable[i];

			for (var fieldPath in map) {
				var mappingFunc = map[fieldPath],
					newValue;

				var parentPath=fieldPath.match(/(.*)\.[^\.]+$/);
					parentPath=parentPath[1];
				var parent=qtools.getSurePath(element, parentPath),
					innerFieldPath=fieldPath.replace(parentPath+'.', '');

				if (qtools.toType(parent)=='array'){
					for (var j=0, len2=parent.length; j<len2; j++){
						var arrayElement=parent[j];
						newValue = mappingFunc(arrayElement);
						qtools.putSurePath(arrayElement, innerFieldPath, newValue);
					}
				}
				else{
					newValue = mappingFunc(element);
					qtools.putSurePath(element, fieldPath, newValue);
				}


			}

		}
	}

	this.select = function(selectorFunction) {
		var outList = [];
		for (var i = 0, len = this.workingTable.length; i < len; i++) {
			var element = this.workingTable[i];
			if (selectorFunction(element)) {
				outList.push(element);
			}
		}

		this.workingTable = outList;
	}

	this.getResult = function() {
		if (global.localEnvironment.testServer) {
			qtools.message("SQLizer Result: " + this.workingTable.length + " records");
		}
		return this.workingTable;
	}

	//INITIALIZATION ====================================

	this.reset(this.tables);

	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;











