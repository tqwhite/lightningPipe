'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;
	this.ping=qtools.ping;

	qtools.validateProperties({
		subject: args,
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'queryInfo',
				optional: false
			},
			{
				name: 'clientProfile',
				optional: false
			},
			{
				name: 'removeUnauthorizedElements',
				optional: false
			},
			{
				name: 'dictionary',
				optional: false
			},
			{
				name: 'dataConverter',
				optional: false
			}
		]
	});


	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};



	var dataConverter = this.dataConverter;


	//LOCAL FUNCTIONS ====================================

	var callbacksDone = function() {

		for (var i in self.callbackList) {
			var element = self.callbackList[i];
			if (element === '') {
				return false;
			}
		}
		return true;
	}


	var generateCallback = function(id) {

		if (typeof (self.callbackList) == 'undefined') {
			self.callbackList = {};
		}

		self.callbackList[id] = '';
		
		return function(err, result, converterName) { //CALLBACK FROM ACCESSOR ============================
			var myId = id;
			
			if (err){
				var outputTmp = {
					status: -1,
					data: err
				}
				err.meta=qtools.mergeMetaData(err.meta);
				self.parentCallback(outputTmp);
				return;
			}

			if (result.type == 'list') {
				result.data = self.removeUnauthorizedElements(result.data, lookupControl.finalDataName);
				result.data = addUriList(result.data, lookupControl.queryPath);
			}
			else{
		

				if (converterName){
					var converterGenerator = require(converterName),
					converter=new converterGenerator({dictionary:self.dictionary});
					result.data = converter.convert(result.data, result.type);
				}

			}

			self.callbackList[myId] = result.data;

			if (callbacksDone()) {
				var assembler = self.dictionary.getAssembler(self.primarySchema);
				var outObj = assembler.execute(self.callbackList);
				var outputTmp = {
					status: 1,
					data: outObj
				}
				self.parentCallback(outputTmp); //to event getDataComplete, via hybrid model
			}

		}
	}


	var addUriList = function(rawData, queryPath) {
		var outList = [];
		for (var i = 0, len = rawData.length; i < len; i++) {
			var element = rawData[i].replace(/\..*$/, ''),
				schemaName = self.dataConverter.dictionary.getSchemaName(element),
				uri = global.localEnvironment.baseUri + queryPath + '/' + (schemaName ? schemaName : element),
				workingItem = {
					id: element
				};

			;

			outList.push({
				data: workingItem,
				uri: uri
			});
		}
		return outList;
	}

	//METHODS AND PROPERTIES ====================================


	
	var digestQuery = function(query, path, newQuery, status) {
		//note: query originates in apiDefinition.parse()
		
		path = path ? path : '';
		newQuery = newQuery ? newQuery : '';
		
		//recursion alert!
		
		var current = query.shift(),
			newPath,
			isAllowed = self.clientProfile.dataAccess.isAllowed(current.name, current.value),
			status = status ? status : {},
			badStatus = {};

		if (!isAllowed) {
			badStatus = {
				status: -1,
				data: {
					errno: -1,
					message: "Not allowed to access " + current.name + "=" + current.value
				}
			};
			self.badStatus = badStatus;
		}

		if (qtools.isEmpty(query)) {
			//this is the last element
			var status = qtools.extend(status, badStatus),
				fileName;

			newQuery = newQuery + '/' + current.name + (current.value == 'list' ? '' : '/' + current.value);

			newQuery = newQuery.replace(/^\//, '');

			self.dataConverter.dictionary.setMainDefinitionName(current.value); //and when I move the query parsing to the top, this woud move, too

			var componentSchemaInfo = self.dataConverter.dictionary.getComponentSchemaInfo(current.value),
				fileName = current.value;
	
			
			if (typeof(componentSchemaInfo)=='undefined'){
				return;
			}

		

			var outObjTemplate = {
				dataLocation: '',
				type: current.value == 'list' ? 'list' : 'data',
				queryPath: newQuery,
				finalDataName: current.name,
				finalValue: current.value,
				status: status,
				queryInfo:self.queryInfo
			};

			var outObj = outObjTemplate;
				
			if (current.value == 'list') {
				var fileName = current.value;
				newPath = path + (current.value == 'list' ? '' : '/' + fileName);
				outObj.dataLocation = newPath;

			} else if (componentSchemaInfo) {
				self.primarySchema=current.value;
				var outList = [];


				var list = componentSchemaInfo.componentList;

				for (var i = 0, len = list.length; i < len; i++) {
					var workingObj = qtools.clone(outObjTemplate),
						element = list[i];


					workingObj.sql = element.accessInfo.mssql.query;
					workingObj.finalValue = element.schemaName;

					outList.push(workingObj);

				}
				return outList;

			} else {
				fileName = fileName;
				newPath = path + (current.value == 'list' ? '' : '/' + fileName);
				outObj.dataLocation = newPath;

			}
			return [outObj];
			
		} else {
			newPath = path + (current.value == 'list' ? '' : '/' + current.value);
			newQuery = newQuery + '/' + current.name + (current.value == 'list' ? '' : '/' + current.value);
			newQuery = newQuery.replace(/^\//, '');
			return digestQuery(query, newPath, newQuery, qtools.extend(status, badStatus));
		}

	} //end of digestQuery()

	//INITIALIZATION ====================================

	/*
		The idea is that lightningPipe supports multiple protocols (UFF, csv?, who knows what)
		and, perhaps, subsequent versions of them as time goes by.
		
		clientProfile contains a list (hash) of potential data sources (dataSourceAvailable), one
		of which is selected based on the incoming URI. The chosen dataSource specifies the
		file path (or database access specs) where the data can be found. It also specifies the
		data dictionary definition (for UFF files, it's studentPlansInitial). THIS MAY 
		BE A PROBLEM because it turns out that file and mssql have substantially different
		dictionary needs.
		
		In addition, the server.js adds the 'api' property to the client profile. The api contains,
		mainly, the parse() routine (used by hybridModel) that interprets the incoming URI into 
		a list of name/value pairs that get fed to digestQuery() in the fileEngine to 
		produce the lookupControlList or in the mssqlEngine to produce an SQL query.
		
		The api property also specifies the 'driver' (eg, fileAccessor) that is used to
		actually execute the calls to the data source. This could vary based on the version
		of the api being used. That is, while fileAccessor is good for UFF v1.0/file, it might
		not be adequate for UFF v2.0/file (UFF v2.0/mssql). (THIS MIGHT BE BAD because it 
		suggests that the api knows or cares about the kind of driver to use but I can't 
		get away from the idea that it might and I can't think of a better place for it.)
		
		At the engine level, the responsibilities are
			1)	interpret the request (self.queryInfo) with digestQuery()
			2)	queue up an access function for each
			3)	execute the access callback that
				a)	converts to JSON (listing or data, as appropriate)
				b)	removes any disallowed listing items from the JSON
				c)	once all accesses have returned, execute the dataConverter's assembler()
				d)	HAND IT TO THE PARENT CALLBACK
		
	*/
	
	this.dataAccessorGenerator = require(self.clientProfile.dataSource.api.accessorList[self.clientProfile.dataSource.type]); //at first, it's fileAccessor.js
	
	var lookupControlList=digestQuery(qtools.clone(self.queryInfo), '');
	if (typeof(lookupControlList)=='undefined'){
		self.badStatus={
				status: -1,
				data: {
					message: "Bad URI Parameter: '"+self.queryInfo[self.queryInfo.length-1].value+"' is probably misspelled",
					evidence:self.queryInfo
				}
			}
		lookupControlList=[]; //skip access
	}

	this.dataAccessorList = [];
	for (var i = 0, len = lookupControlList.length; i < len; i++) {
		var lookupControl = lookupControlList[i],
			dataAccessor=new this.dataAccessorGenerator({
				dataSource: self.clientProfile.dataSource,
				lookupControl: lookupControl,
				dictionary:self.dataConverter.dictionary
			});


		this.dataAccessorList.push({
			schema: lookupControl.finalValue,
			dataAccessor:dataAccessor
		});

	}


	this.executeQuery = function(callback) {
		//this callback is specified in the call toe executeQuery() in hybridModel
		//it passes straight through with event getDataComplete
		
		if (typeof (self.badStatus) != 'undefined') {
			callback(self.badStatus);
			return;
		}
		self.parentCallback = callback;


		var list = this.dataAccessorList;
		for (var i = 0, len = list.length; i < len; i++) {
			var element = list[i];
			element.dataAccessor.getRawData(generateCallback(element.schema));
		}

	}

	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;





