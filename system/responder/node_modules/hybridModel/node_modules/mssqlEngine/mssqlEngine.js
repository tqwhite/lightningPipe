'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;
	this.ping = qtools.ping;

	qtools.validateProperties({
		subject: args,
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'queryInfo',
				optional: false
			},
			{
				name: 'clientProfile',
				optional: false
			},
			{
				name: 'removeUnauthorizedElements',
				optional: false
			},
			{
				name: 'dictionary',
				optional: false
			},
			{
				name: 'dataConverter',
				optional: false
			}
		]
	});

	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};



	var dataConverter = this.dataConverter;


	this.retryCount = 1;

	this.objectId = '';

	for (var i = 0, len = this.queryInfo.length; i < len; i++) {
		var element = this.queryInfo[i];
		this.objectId += element.value + '.';
	}

	//LOCAL FUNCTIONS ====================================

	var callbacksDone = function() {

		for (var i in self.callbackList) {
			var element = self.callbackList[i];
			if (element === '') {
				return false;
			}
		}
		return true;
	}


	var generateCallback = function(id) {

		if (typeof (self.callbackList) == 'undefined') {
			self.callbackList = {};
		}

		self.callbackList[id] = '';

		return function(err, result, converterName) { //CALLBACK FROM ACCESSOR ============================
			var myId = id,
				myObjectId = self.objectId;


			if (err) {

				if (!self.outStandingAccesses[myId].dataAccessor) {
					var queryInfo = "data accessor is missing";
				} else {
					var queryInfo = self.outStandingAccesses[myId].dataAccessor.lookupControl.databaseParameters;
				}
				if (self.outStandingAccesses[myId].retryCount < self.retryCount) {


					self.outStandingAccesses[myId].retryCount++;
					self.dataAccessorList.push(self.outStandingAccesses[myId]);
					delete self.outStandingAccesses[myId]; //will be put back on when it is executed again

					global.localEnvironment.log.fatal({
						source: 'mssqlEngine.callbackRetry',
						data: {
							err: err,
							mssqlEngineId: self.objectId,
							accessId: myId,
							query: queryInfo
						}
					});

					return;
				}
				qtools.dump(queryInfo);

				global.localEnvironment.log.fatal({
					source: 'mssqlEngine.callbackFailure',
					data: {
						err: err,
						note: 'this error deletes all pending queries to terminate execution',
						mssqlEngineId: self.objectId,
						accessId: myId,
						query: queryInfo
					}
				});

				self.dataAccessorList = [];

				var outputTmp = {
					status: -1,
					data: err
				}
				err.meta = qtools.mergeMetaData(err.meta);
				self.parentCallback(outputTmp);
				return;
			}


			if (!err && self.dataAccessorList.length) {
				var element = self.dataAccessorList.pop();

				delete self.outStandingAccesses[myId];

				element.outStandingAccessId = element.schema; //I just want to be able to see this when needed, sw doesn't need it
				self.outStandingAccesses[element.schema] = element;

				element.dataAccessor.getRawData(element.callback);
			}

			if (result.type == 'list') {
				result.data = self.removeUnauthorizedElements(result.data, lookupControl.finalDataName);
				result.data = addUriList(result.data, lookupControl.queryPath);
			} else {


				if (converterName) {
					var converterGenerator = require(converterName),
						converter = new converterGenerator({
							dictionary: self.dictionary
						});
					result.data = converter.convert(result.data, result.type);
				}

			}

			self.callbackList[myId] = result.data;

			if (callbacksDone()) {
				var assembler = self.dictionary.getAssembler(self.primarySchema);
				var outObj = assembler.execute(self.callbackList);
				var outputTmp = {
					status: 1,
					data: outObj
				}
				self.parentCallback(outputTmp); //to event getDataComplete, via hybrid model
			}

		}
	}


	var addUriList = function(rawData, queryPath) {
		var outList = [];
		for (var i = 0, len = rawData.length; i < len; i++) {
			var element = rawData[i].replace(/\..*$/, ''),
				schemaName = self.dataConverter.dictionary.getSchemaName(element),
				uri = global.localEnvironment.baseUri + queryPath + '/' + (schemaName ? schemaName : element),
				workingItem = {
					id: element
				};

			;

			outList.push({
				data: workingItem,
				uri: uri
			});
		}
		return outList;
	}

	//METHODS AND PROPERTIES ====================================



	var digestQuery = function(query, path, newQuery, status) {
		//note: query originates in apiDefinition.parse()

		path = path ? path : '';
		newQuery = newQuery ? newQuery : '';

		//recursion alert!

		var current = query.shift(),
			newPath,
			isAllowed = self.clientProfile.dataAccess.isAllowed(current.name, current.value),
			status = status ? status : {},
			badStatus = {};

		if (!isAllowed) {
			badStatus = {
				status: -1,
				data: {
					errno: -1,
					message: "Not allowed to access " + current.name + "=" + current.value
				}
			};
			self.badStatus = badStatus;
		}

		if (qtools.isEmpty(query)) {
			//this is the last element
			var status = qtools.extend(status, badStatus),
				fileName;

			newQuery = newQuery + '/' + current.name + (current.value == 'list' ? '' : '/' + current.value);

			newQuery = newQuery.replace(/^\//, '');

			self.dataConverter.dictionary.setMainDefinitionName(current.value); //and when I move the query parsing to the top, this woud move, too

			var componentSchemaInfo = self.dataConverter.dictionary.getComponentSchemaInfo(current.value),
				fileName = current.value;


			if (typeof (componentSchemaInfo) == 'undefined' && current.value!='list') {

					global.localEnvironment.log.fatal({
						source: 'mssqlEngine.digestQuery',
						data: {
							err: "self.dataConverter.dictionary.getComponentSchemaInfo('"+current.value+"') returned no value)",
							mssqlEngineId: self.objectId,
							query: query
						}
					});
				return;
			}



			var outObjTemplate = {
				dataLocation: '',
				type: current.value == 'list' ? 'list' : 'data',
				queryPath: newQuery,
				finalDataName: current.name,
				finalValue: current.value,
				status: status,
				queryInfo: self.queryInfo
			};

			var outObj = outObjTemplate;

			if (current.value == 'list') {
				var fileName = current.value;
				newPath = path + (current.value == 'list' ? '' : '/' + fileName);
				outObj.dataLocation = newPath;

			} else if (componentSchemaInfo) {
				self.primarySchema = current.value;
				var outList = [];


				var list = componentSchemaInfo.componentList;

				for (var i = 0, len = list.length; i < len; i++) {
					var workingObj = qtools.clone(outObjTemplate),
						element = list[i];


					workingObj.sql = element.accessInfo.mssql.query;
					workingObj.finalValue = element.schemaName;

					outList.push(workingObj);

				}
				return outList;

			} else {
				fileName = fileName;
				newPath = path + (current.value == 'list' ? '' : '/' + fileName);
				outObj.dataLocation = newPath;

			}
			return [outObj];

		} else {
			newPath = path + (current.value == 'list' ? '' : '/' + current.value);
			newQuery = newQuery + '/' + current.name + (current.value == 'list' ? '' : '/' + current.value);
			newQuery = newQuery.replace(/^\//, '');
			return digestQuery(query, newPath, newQuery, qtools.extend(status, badStatus));
		}

	} //end of digestQuery()

	//INITIALIZATION ====================================

	/*
		The idea is that lightningPipe supports multiple protocols (UFF, csv?, who knows what)
		and, perhaps, subsequent versions of them as time goes by.
		
		clientProfile contains a list (hash) of potential data sources (dataSourceAvailable), one
		of which is selected based on the incoming URI. The chosen dataSource specifies the
		file path (or database access specs) where the data can be found. It also specifies the
		data dictionary definition (for UFF files, it's studentPlansInitial). THIS MAY 
		BE A PROBLEM because it turns out that file and mssql have substantially different
		dictionary needs.
		
		In addition, the server.js adds the 'api' property to the client profile. The api contains,
		mainly, the parse() routine (used by hybridModel) that interprets the incoming URI into 
		a list of name/value pairs that get fed to digestQuery() in the fileEngine to 
		produce the lookupControlList or in the mssqlEngine to produce an SQL query.
		
		The api property also specifies the 'driver' (eg, fileAccessor) that is used to
		actually execute the calls to the data source. This could vary based on the version
		of the api being used. That is, while fileAccessor is good for UFF v1.0/file, it might
		not be adequate for UFF v2.0/file (UFF v2.0/mssql). (THIS MIGHT BE BAD because it 
		suggests that the api knows or cares about the kind of driver to use but I can't 
		get away from the idea that it might and I can't think of a better place for it.)
		
		At the engine level, the responsibilities are
			1)	interpret the request (self.queryInfo) with digestQuery()
			2)	queue up an access function for each
			3)	execute the access callback that
				a)	converts to JSON (listing or data, as appropriate)
				b)	removes any disallowed listing items from the JSON
				c)	once all accesses have returned, execute the dataConverter's assembler()
				d)	HAND IT TO THE PARENT CALLBACK

	*/

	this.dataAccessorGenerator = require(self.clientProfile.dataSource.api.accessorList[self.clientProfile.dataSource.type]); //at first, it's fileAccessor.js

	var lookupControlList = digestQuery(qtools.clone(self.queryInfo), '');
	if (typeof (lookupControlList) == 'undefined') {
		self.badStatus = {
			status: -1,
			data: {
				message: "Bad URI Parameter: '" + self.queryInfo[self.queryInfo.length - 1].value + "' is probably misspelled",
				evidence: self.queryInfo
			}
		}
		lookupControlList = []; //skip access
	}

	this.dataAccessorList = [];
	for (var i = 0, len = lookupControlList.length; i < len; i++) {
		var lookupControl = lookupControlList[i],
			dataAccessor = new this.dataAccessorGenerator({
				dataSource: self.clientProfile.dataSource,
				lookupControl: lookupControl,
				dictionary: self.dataConverter.dictionary
			});


		this.dataAccessorList.push({
			schema: lookupControl.finalValue,
			dataAccessor: dataAccessor,
			callback: generateCallback(lookupControl.finalValue),
			retryCount: 0
		});

	}

	this.executeQuery = function(callback) {
		//this callback is specified in the call to executeQuery() in hybridModel
		//it passes straight through with event getDataComplete

		if (typeof (self.badStatus) != 'undefined') {
			callback(self.badStatus);
			return;
		}
		self.parentCallback = callback;

		if (!self.outStandingAccesses) {
			self.outStandingAccesses = {};
		}

		//spawn the first one, the rest are done in the callback made by generateCallback() above
		var element = this.dataAccessorList.pop();
		element.outStandingAccessId = element.schema; //I just want to be able to see this when needed, sw doesn't need it
		self.outStandingAccesses[element.schema] = element; //same as id in generateCallback()

		element.dataAccessor.getRawData(element.callback);

		// 		var list = this.dataAccessorList;
		// 		for (var i = 0, len = list.length; i < len; i++) {
		// 			var element = list[i];
		// 			element.dataAccessor.getRawData(generateCallback(element.schema));
		// 		}


	}

	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;








