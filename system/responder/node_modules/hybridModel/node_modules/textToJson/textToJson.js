'use strict';
/*

This absorbs a tab delimited spreadsheet file with field names in the first row.
The data can be manipulated in a couple of ways and then converted to a simple
Javascript object list. A JSON version is also maintained.

// OBSOLETE
// Give a new textToJson a file name and it will grab the contents for processing
// 	var textToJson
// =require('./textToJson.js'),
// 		fileName = "coreOrig.txt";
// 	textToJson=new textToJson(fileName, [definition | 'fileDataFormat']);
//OBSOLETE
	
"definition" is an entry from a dictionary (eg, uffDictionary.js)

The file read is ASYNCHRONOUS and is reported via the 'textToJson.gotData' event.

	textToJson.on('textToJson.gotData', 
		function(){
		textToJson.processLines(function(){ ... });
		textToJson.mapFieldNames({ ... }, 'exclusive');
		textToJson.convert();
		console.log(textToJson.finishedObject);
	});

You can run a function on each line in the file, eg, this adds a newline to each line
	var transformations=function(item, inx, entire){
		return item+"\n";
	};
	textToJson.processLines(transformations);
	
You can also shape the final object by mapping the field names and, optionally, discarding columns 
that are not listed in the map. The name of each property corresponds to a name in the header row
of the incoming data. The value of the property is the name that will be used for the corresponding 
property in the output data. Adding the exclusive flag causes columns to be discarded. If it
is omitted, names are mapped and other columns become properties using their original names.

	textToJson.mapFieldNames(
		{ 
			GUID:'RefId', 
			Number:'Number', 
			'Parent GUID':'ParentStandardRefId'
		}, 
		'exclusive');

Once you've translated everything, you can convert into and array of simple javascript objects, ie, [{fieldNameA:'dataA', fieldNameB, 'dataB'}]
	textToJson.makeSimpleObjects();

You can access the results from these properties:

	textToJson.finishedObject
	
*/
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util'),
	fs = require("fs");

//START OF moduleFunction() ============================================================
var moduleFunction = function(args) {

	events.EventEmitter.call(this);

	qtools.validateProperties({
		subject: args,
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'dictionary',
				optional: false
			}
		]
	});
	
	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		},
		
		getDefinition=function(definitionName){
			self.definition=self.dictionary.getDefinition(definitionName);
		},

		init = function(lineList) {

			self.lineList = lineList;

			self.skipFirstLine = false; //isFirstLineHeader();

			if (self.skipFirstLine) {
				qtools.message('found self.skipFirstLine');
			}
			
			if (self.definition.fileDataFormat == 'simpleEntityWithFieldHeader') {
				self.headerList = self.lineList[0];
				self.skipFirstLine = true;
			} else {
				self.headerList = self.definition.fieldList;
			}
			self.rawHeaderList = qtools.clone(self.headerList);

		
		
		
		},

		isFirstLineHeader = function() {
			var possibleFileFieldList = self.headerList = self.lineList[0];

			if (qtools.toType(self.definition.fieldList) == 'array' &&
				qtools.isNotEmpty(self.definition.fieldList)) {

				var list = self.definition.fieldList;

				//determine if first line is a field list
				var isIdentical = true;
				for (var i = 0, len = list.length; i < len; i++) {
					var definitionName = list[i],
						fileItem = possibleFileFieldList[i];

					if (definitionName == fileItem) {
						continue;
					} else {
						isIdentical = false;
					}
				}
			}

			return isIdentical;
		},

		defaultTransformations = function(row, i, list) {
		
		
		
	var outRow=[];
	for (var i=0, len=row.length; i<len; i++){
		var element=row[i];
			outRow[i] = element.replace(/<!newGuid!>/g, qtools.newGuid()); //note: I have subsequently learned that Expressbook generates the RefId if none is supplied for a new object

	}
		
			return outRow;
		},

		processLines = function(callback, suppressDefaultTransformations) {

			suppressDefaultTransformations = (typeof (suppressDefaultTransformations) != 'undefined') ? applyDefaultTransformations : false

			var list = self.lineList,
				outArray = [];

			if (self.skipFirstLine) {
				var start = 1;
			} else {
				var start = 0;
			}

			for (var i = start, len = list.length; i < len; i++) {
				var element = list[i];
				if (typeof (callback) == 'function') {
					element = callback(element, i, list);
				}

				if (!suppressDefaultTransformations) {
					element = defaultTransformations(element, i, list);
				}
				outArray.push(element);
			}

			self.lineList = outArray;
		},

		makeSimpleObjects = function() {

			var importAction = qtools.getSurePath(self, 'definition.targetAssembler.importer');
			var translatorAction = qtools.getSurePath(self, 'definition.targetAssembler.translator');
			var translations = qtools.getSurePath(self, 'definition.targetTranslation');

			if (typeof (importAction) != 'undefined') {
				self.finishedObject = importAction({
					lineList: self.lineList,
					sourceObjectList: self.sourceObjectList
				});
				self.finishedObject = translatorAction(self.finishedObject, translations);

				for (var i in self.finishedObject) {
					self.finishedObject[i] = objectTransform(self.finishedObject[i]);
				}
			} else {
				self.finishedObject = simpleConversion();
			}
		},

		simpleConversion = function() {

			var outArray = [];
			var list = self.lineList;

			for (var i = 0, len = list.length; i < len; i++) {

				var element = list[i];

				var sourceItem = {};
				var len2 = self.rawHeaderList.length;
				for (var j = 0, len2; j < len2; j++) {
					sourceItem[self.rawHeaderList[j]] = element[j];
				}

				self.sourceObjectList.push(sourceItem);

				var itemString = '';

				var len2 = element.length;
				if (len2 === 1 && element[0] === '') {
					break;
				} //ignore empty lines

				var itemObj = {};
				for (var j = 0, len2; j < len2; j++) {
					if (self.headerList[j]) {
						itemObj[self.headerList[j]] = element[j];
					}

				}

				var list2 = self.definition.targetTranslation;
				for (var j in list2) {

					var translator = list2[j];
					var type = typeof (translator),
						outValue;
					switch (type) {
						case 'function':
							outValue = translator(itemObj, sourceItem);
							break;
						default:
							outValue = translator;
							break;
							break;

					}

					if (outValue != "<!omitProperty!>") {
						itemObj[j] = outValue;
					} else {
						delete itemObj[j];
					}


				}

				outArray.push(itemObj);
			}

			return objectTransform(outArray);
		},

		objectTransform = function(inObj) {
			//this changes compound field names, eg, "term.RefId":value, into objects, term:{RefId:value} or term.RefId.value
			var outList = [];
			for (var i = 0, len = inObj.length; i < len; i++) {
				var workingObj = inObj[i];

				for (var key in workingObj) {
					if (key.match(/\./)) {
						qtools.putSurePath(workingObj, key, workingObj[key]);
						delete workingObj[key];
					}
				}
				outList.push(workingObj);
			}
			return outList;
		},

		mapFieldNames = function(map) {
			var exclusive = true; //could add control later that allows non-mapped fields to be retained
			var removeEmpty = false; //!(typeof(removeEmpty)=='undefined' || removeEmpty==='' || removeEmpty===false);

			map = typeof (map) != 'undefined' ? map : self.definition.targetMap;

			if (qtools.isNotEmpty(map)) {
				self.headerList.map(function(item, inx, entire) {

					if (typeof (map[item]) == 'function') {
						entire[inx] = map[item](item, inx, entire);
					} else {

						var newName = map[item];
						if (typeof (map[item]) != 'undefined') {
							entire[inx] = map[item];
						} else {
							if (exclusive) {
								entire[inx] = '';
							}
						}
					}

				});
			}

			if (removeEmpty) {
				self.headerList = qtools.removeNullElements(self.headerList);
			}

		},

		assemble = function() {

			var assemblerAction = qtools.getSurePath(self, 'definition.targetAssembler.executeAssembling');
			self.rawObjectList = qtools.clone(self.finishedObject); //for future reference

			if (typeof (assemblerAction) != 'undefined') {
				self.finishedObject = assemblerAction({
					importedObjectList: self.finishedObject,
					lineList: self.lineList
				});
			} else if (qtools.isNotEmpty(self.definition.targetAssembler)) {
				qtools.die({
					msg: "definition.targetAssembler has no executeAssembling method",
					definition: self.definition
				});
			}
			//else, no assembler and it's not missing from the data structure, so, no assembly required

		},

		writeLines = function() {
			console.log("WRITELINES APPEARS TO BE UNUSED");
			// 				var list=self.outList;
			// 				for (var i=0, len=list.length; i<len; i++){
			// 					var element=list[i];
			// 					process.stdout.write(element);
			// 				}
		}

		//INITIALIZE OBJECT ====================================

	this.sourceObjectList = [];

	//BUILD RETURN OBJECT ====================================
	this.processLines = processLines;
	this.makeSimpleObjects = makeSimpleObjects;
	this.assemble = assemble;
	this.mapFieldNames = mapFieldNames;
	this.writeLines = writeLines;
	this.forceEvent = forceEvent;
	
	
	this.reflectTmp=function(inData, callback){
		
		callback(inData);
	}
	
	this.convert=function(inData, definitionName){
		getDefinition(definitionName);
		init(inData);
		self.mapFieldNames();
		self.processLines();
		self.makeSimpleObjects();
		self.assemble();
		return self.finishedObject
	}
	return this;
};
//END OF moduleFunction() ============================================================
util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;

