'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util'),
	fs = require('fs');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;
	this.ping = qtools.ping;

	qtools.validateProperties({
		subject: args,
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'fileName',
				optional: false
			},
			{
				name: 'outputSpec',
				optional: true
			},
			{
				name: 'config',
				optional: false
			}
		]
	});


	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};

	//LOCAL FUNCTIONS ====================================

	var stripHeaderRow = function(inData) {
		var tmp = inData.split(self.lineEnding);

		delete tmp[0];
		return tmp.join(self.lineEnding);
	}

	//METHODS AND PROPERTIES ====================================

	self.alreadyKeptOne = false;

	this.lineEnding=this.config.runtimeParameters.lineEnding?this.config.runtimeParameters.lineEnding:'\n';

	this.dataBuffer = '';

	if (this.outputSpec.fileFormat == 'tabDelimitted') {
		var tmp = require('objectFlattener');
		this.flattener = new tmp({
			config: this.config
		});
	} else {
		throw "fileWrite.js says, output.fileFormat is wrong, only 'tabDelimitted' supported presently";
	}

	this.takeItAway = function(dataBuffer, fileWriteCallback) {
		var inData = dataBuffer.getBufferData(),
			flatSpecs = dataBuffer.giveFlatSpecs(),
			data = self.flattener.flattenToString(inData, flatSpecs);


		var parentPath = qtools.getSurePath(self.outputSpec || {}, "context.parentPath"),
			header = qtools.getSurePath(self.outputSpec || {}, "context.header"),
			append = qtools.getSurePath(self.outputSpec || {}, "context.append"),
			extension = qtools.getSurePath(self.outputSpec || {}, "context.fileExtension");
			
		parentPath = parentPath ? parentPath : '';
		extension = extension ? extension : '';
		
		append = qtools.strToBool(append);
		header = qtools.strToBool(header);
		
		if (!header || self.alreadyKeptOne) {
			data = stripHeaderRow(data);
		} else {
			self.alreadyKeptOne = true;
		}

		self.dataBuffer += data;
		
		var filePath = parentPath + self.fileName+extension;

		var enhancedCallback = function(err, result) {
			result = result ? result : {
					targetDataId: filePath,
					summaryString: dataBuffer.getBufferData().length.toString() + ' rows'
				}


			global.localEnvironment.log.info({
				source: 'fileWriter.js',
				type: 'finalInfo',
				evidence: result
			});

			fileWriteCallback(err, result);
		}

		qtools.writeSureFile(filePath, data, {
			callback: enhancedCallback,
			append: append
		});
		return data.length;
	}

	//INITIALIZATION ====================================

	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;

