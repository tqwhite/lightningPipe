'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util'),
	async = require('async');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;
	this.metaData = {};
	this.addMeta = function(name, data) {
		this.metaData[name] = data;
	}

	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'input',
				optional: false
			},
			{
				name: 'process',
				optional: false
			},
			{
				name: 'export',
				optional: false
			},
			{
				name: 'config',
				optional: false
			},
			{
				name: 'label',
				optional: true
			}
		]
	});


	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};


	//LOCAL FUNCTIONS ====================================


	var extractData = function(next) {
		var sqlList = [];

		for (var tableName in self.bufferSet) {



			var buffer = self.bufferSet[tableName],
				bufferData = buffer.getBufferData();;

			self.workingDataList[tableName] = bufferData;

		}



		next();

	}

	var fillOutputBuffer = function(taskItem, next) {
		var newBuffer = taskItem.buffer,
			tableName = taskItem.tableName,
			exportName = taskItem.exportName;
		newBuffer.stash(self.workingDataList[tableName]);
		self.outBufferList[exportName] = newBuffer;
		next();
	}

	var runMapping = function(processItem) {

		var processFunction;

		eval("processFunction=" + processItem.functionString);

		if (typeof (self.workingDataList[processItem.destTableName]) == 'undefined') {

			self.workingDataList[processItem.destTableName] = [];
		}

		var tmp = self.workingDataList[processItem.sourceTableName].map(processFunction);
		self.workingDataList[processItem.destTableName] = tmp;
	}

	var runSummary = function(processItem) {

		var indexFunction,
			summaryFunction,
			indexTable = {};

		eval("indexFunction=" + processItem.indexFunction);

		eval("summaryFunction=" + processItem.summaryFunction);


		for (var i = 0, len = self.workingDataList[processItem.sourceTableName].length; i < len; i++) {
			var element = self.workingDataList[processItem.sourceTableName][i],
				inx = indexFunction(element);

			if (typeof (indexTable[inx]) == 'undefined') {
				indexTable[inx] = [];
			}
			indexTable[inx].push(element);
		}

		var workingTable = [];

		for (var i in indexTable) {
			var element = qtools.clone(indexTable[i]),
				summaryRec = summaryFunction(element, i, indexTable);
			workingTable.push(summaryRec);
		}

		self.workingDataList[processItem.destTableName] = workingTable;
	}








	var executeProcesses = function(next) {
		var queryList = [];
		for (var i = 0, len = self.process.length; i < len; i++) {
			var processItem = self.process[i]
			switch (processItem.type) {
				case 'map':
					runMapping(processItem.specs);
					break;
				case 'summarize':
					runSummary(processItem.specs);
					break;
			}
		}


		next();
	}

	var generateResults = function(next) {
		var taskList = [];

		for (var i = 0, len = self.export.length; i < len; i++) {
			var exportItem = self.export[i],
				newBuffer = new dataBufferGenerator({}),
				taskItem = {
					tableName: exportItem.tableName,
					buffer: newBuffer,
					exportName: exportItem.as
				};

			taskList.push(taskItem);


		}
		async.each(taskList, fillOutputBuffer, function(err, result) {
			if (err) {
				handleError(err);
			}
			next()
		});
	}

	//METHODS AND PROPERTIES ====================================


	this.execute = function(inData, callback) {
		self.bufferSet = qtools.clone(inData);
		var outBufferList = {},
			taskList = [];
			
		if (self.config.cmdLineSwitches.verbose) {
			console.log('self.label=' + self.label + '\n');
		}
		
		taskList.push(extractData);
		taskList.push(executeProcesses);
		taskList.push(generateResults);

		async.series(taskList, function() {
			global.localEnvironment.log.info({
				source: 'applyFunction.js',
				type: 'finalResult',
				evidence: self.tableCounts
			});

			callback(self.outBufferList);
		});

	}

	//INITIALIZATION ====================================

	var dataBufferGenerator = require('dataBuffer');

	this.workingDataList = {};
	this.outBufferList = {};

	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;

















