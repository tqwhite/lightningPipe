'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util'),
	async = require('async');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;
	this.metaData = {};
	this.addMeta = function(name, data) {
		this.metaData[name] = data;
	}

	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'input',
				optional: false
			},
			{
				name: 'process',
				optional: false
			},
			{
				name: 'export',
				optional: false
			},
			{
				name: 'config',
				optional: false
			}
		]
	});


	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};


	//DATBASE UTILITY FUNCTIONS ====================================

	var showAllCounts = function() {
		db.all("SELECT name FROM sqlite_master WHERE type='table';", function(err, result) {
			if (err) {
				console.log('show tables err=' + err + '\n');
				return;
			}
			for (var i = 0, len = result.length; i < len; i++) {
				var element = result[i],
					tableName = element.name;
				db.all("select count(*) as 'sqlizer2:" + tableName + "' from " + tableName, function(err, result) {
					if (err) {
						console.log('show query err=' + err + '\n');
					}
					qtools.dump(result[0]);
				});
			}
		});
	}

	var showTables = function(next) {
		db.all("SELECT name FROM sqlite_master WHERE type='table';", function(err, result) {
			if (err) {
				console.log('show tables err=' + err + '\n');
			}
			qtools.dump({
				'=-=== tableList =====': result
			});
			next();
		});
	}

	var describeTable = function(tableName) {
		db.all("PRAGMA table_info([" + tableName + "]);", function(err, result) {
			if (err) {
				console.log('show tables err=' + err + '\n');
			}
			qtools.dump({
				'=-=== fieldList =====': result
			});
		});

	}

	var showQuery = function(query, label) {
		label = label ? label : '';
		db.all(query, function(err, result) {
			if (err) {
				console.log('show query err=' + err + '\n');
			}
			if (label) {
				console.log('\n\n' + label);
			}
			qtools.dump({
				'=-=== fieldList =====': result
			});
		});

	}

	//LOCAL FUNCTIONS ====================================

	var handleError = function(err) {
		if (err) {
			//	console.trace();
			throw (err);
		}
	}

	var getPropertyNameList = function(sampleRow) {
		var outArray = [];

		for (var propertyName in sampleRow) {
			outArray.push(propertyName);
		}
		return outArray;
	}

	var genCreateTableString = function(tableName, propertyNameArray) {
		var fieldDefString = '',
			outString,
			existingFieldList = [];

		for (var i = 0, len = propertyNameArray.length; i < len; i++) {
			var propertyName = propertyNameArray[i];
			fieldDefString += '"' + propertyName + '"' + ' TEXT, '; //sqlite requires weird field names, eg 504flag, to be escaped
			//fieldDefString += propertyName + ' TEXT, '; //mysql doesn't allow escaping with either apostrophe or quote
		}

		fieldDefString = fieldDefString.replace(/, $/, '');
		outString = "CREATE TABLE " + tableName + " (" + fieldDefString + ")";
		return outString;
	}

	var dbIterator = function(queryString, next) {
		db.run(queryString, function(err, result) {
			if (err) {
				next(err);
				return;
			}
			//no result for createTable);
			next();
		});
	}

	var createTables = function(next) {
		var sqlList = [];

		for (var tableName in self.bufferSet) {

			var buffer = self.bufferSet[tableName],
				bufferData = buffer.getBufferData(),
				propertyNameArray = getPropertyNameList(bufferData[0]),
				createTableString = genCreateTableString(tableName, propertyNameArray);

			self.fieldNameSequenceLists[tableName] = propertyNameArray;

			sqlList.push(createTableString);
		}

		async.each(sqlList, dbIterator, function() {
			next();
		});

	}


	var loadOneTable = function(tableName, recList) {


		var fieldNameSequence = self.fieldNameSequenceLists[tableName];
		var baseQuery = "INSERT INTO " + tableName + " VALUES ",
			query = baseQuery,
			batchCounter = 0,
			queryList = [];

		for (var i = 0, len = recList.length; i < len; i++) {
			var element = recList[i],
				rowString = '';

			for (var j = 0, len2 = fieldNameSequence.length; j < len2; j++) {

				var propertyName = fieldNameSequence[j],
					value=element[propertyName];
				if (typeof(value)=='string'){ value=value.replace(/'/g, "''");}
				rowString += "'" + value + "', ";
			}

			rowString = rowString.replace(/, $/, '');
			query += "(" + rowString + "), ";
			batchCounter++;

			if (batchCounter > 499) {

				query = query.replace(/, $/, '');

				queryList.push(query);

				query = baseQuery;
				batchCounter = 0;
			}
		}

		if (batchCounter) {
			query = query.replace(/, $/, '');
			queryList.push(query);
		}

		return queryList;

	}

	var loadTables = function(next) {
		var queryList = [];

		for (var tableName in self.bufferSet) {
			var buffer = self.bufferSet[tableName],
				bufferData = buffer.getBufferData();

			queryList = queryList.concat(loadOneTable(tableName, bufferData, next));
		}
		async.each(queryList, dbIterator, function() {
			next();
		});
	}

	var executeProcesses = function(next) {
		var queryList = [];
		for (var i = 0, len = self.process.length; i < len; i++) {
			var processItem = self.process[i],
				processSql = processItem.query;
			queryList.push(processSql);



			global.localEnvironment.log.info({
				source: 'sqlizer2.js',
				type: 'query',
				evidence: {
					query: processSql
				}
			});
		}

		async.eachSeries(queryList, dbIterator, function(err, result) {
			if (err) {
				handleError(err);
			}
			next();
		});

	}

	var getTableData = function(taskItem, next) {
		var newBuffer = taskItem.buffer,
			tableName = taskItem.tableName,
			exportName = taskItem.exportName,
			query = 'select * from ' + tableName;

		db.all(query, function(err, result) {
			if (err) {
				handleError(err);
			}
			newBuffer.stash(result);
			self.outBufferList[exportName] = newBuffer;
			next();
		});
	}

	var generateResults = function(next) {
		var taskList = [];

		for (var i = 0, len = self.export.length; i < len; i++) {
			var exportItem = self.export[i],
				newBuffer = new dataBufferGenerator({}),
				taskItem = {
					tableName: exportItem.tableName,
					buffer: newBuffer,
					exportName: exportItem.as
				};

			taskList.push(taskItem);

		}

			async.each(taskList, getTableData, function(err, result) {
				if (err) {
					handleError(err);
				}
				next()
			});
	}

	var getAllCounts = function() {
		db.all("SELECT name FROM sqlite_master WHERE type='table';", function(err, result) {
			if (err) {
				console.log('show tables err=' + err + '\n');
				return;
			}
			for (var i = 0, len = result.length; i < len; i++) {
				var element = result[i],
					tableName = element.name;
				db.all("select count(*) as " + tableName + " from " + tableName, function(err, result) {
					if (err) {


						global.localEnvironment.log.info({
							source: 'sqlizer2.js',
							type: 'ancilliaryError',
							evidence: err
						});
					}
					self.tableCounts.push(result[0]);
				});
			}
		});
	}

	//METHODS AND PROPERTIES ====================================


	this.execute = function(inData, callback) {
		self.bufferSet = qtools.clone(inData);
		var outBufferList = {},
			taskList = [];
			
		taskList.push(createTables);
		taskList.push(loadTables);
//		taskList.push(showTables);
		taskList.push(executeProcesses);
		taskList.push(generateResults);

		async.series(taskList, function() {
			global.localEnvironment.log.info({
				source: 'sqlizer2.js',
				type: 'finalResult',
				evidence: self.tableCounts
			});
//			showAllCounts();

			callback(self.outBufferList);
			db.close();
		});

	}


	//INITIALIZATION ====================================


	var sqlite3 = require('sqlite3');

	if (self.config && self.config.cmdLineSwitches.saveDB) {
		var logDirectory = global.localEnvironment.logFileDirectory,
			fileName = "cloverleafSqliteDb",
			filePath = logDirectory.replace(/\/+$/, '') + '/' + fileName;
			
		qtools.deleteFile(filePath);
		
		if (!self.config.cmdLineSwitches.quiet) {
			qtools.message('sqlite saved DB at: ' + filePath);
		}

		var db = new sqlite3.Database(filePath);
	} else {
		var db = new sqlite3.Database(':memory:');
	}



	var dataBufferGenerator = require('dataBuffer');

	this.outBufferList = {};
	this.fieldNameSequenceLists = {};
	this.tableCounts = [];


	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;













