'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util'),
	fs = require("fs");

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.ping=qtools.ping;
	var self = this,
	forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		}

	qtools.validateProperties({
		subject: args,
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'dataSource',
				optional: false
			}
		]
	});

	//INITIALIZE OBJECT ====================================

	this.target = this.dataSource.receivingSchema

	var definitionName = self.dataSource.definitionName;
	var definitionFilePath = __dirname + '/dataDefinitions/' + definitionName + '.js'


	this.definitions = require(definitionFilePath);

	//BUILD RETURN OBJECT ====================================

	this.mapFileNameXX = function(fileName) {
	//REMOVE THIS FUNCTION and the data in dataSource that supports it. if there is anything worth keeping, it goes in serverProfile
		var localName = self.dataSource.schemaSourceNameMapping ? self.dataSource.schemaSourceNameMapping[fileName] : '',
			definedName = self.definitions[fileName] ? self.definitions[fileName].fileName : '',
			finalName = localName ? localName : definedName;
		return finalName;
	}

	this.getFileName = function(schema) {
		var fileName=schema.accessInfo.file.fileStandardName;

		return fileName;
	}


	this.getComponentSchemaInfo = function(schemaName, serverType) {
		//if this schema has more than one table, access it
		var schema=self.definitions[schemaName];
		var schemaList = schema ? schema.componentSchemaList : '';
		var sqlList=[];
		
	if (typeof(schema)=='undefined'){
		return;
	}	
	
	for (var i=0, len=schemaList.length; i<len; i++){
		var element=schemaList[i];
		sqlList.push(element);
	}


		if (schemaList || sqlList) {
			return {
				schemaName: schemaName,
				componentList: schemaList,
				sqlList:sqlList
			};
		} else {
			return '';
		}
	}

	this.getAssembler = function(schemaName) {
		var targetSchema = this.dataSource.receivingSchema;
		var assemblerSpecs = (self.definitions[schemaName] &&  self.definitions[schemaName].assembler) ? self.definitions[schemaName].assembler[targetSchema] : '';
		/*
		the data definition file, eg, studentPlansInitial	, contains the schema for the
		data types in the dataabase (or file directory). It allows other parts of the
		system (pseudoSql) to interpret things like column sequence and names. It also,
		for each schema, has the option of specifying a special way of assembling the 
		final object sent out of the API. This is done in a two property component that
		specfies the name of the assembler (so it can be required()) and parameters
		that tell it how to operate. assemblerSpecs.params for pseudoSql contains a function
		that accesses the sqlizer and simulates the SQL needed to produce the proper
		output.
		*/

		if (assemblerSpecs) {
			var assembler = require('assemblers/' + assemblerSpecs.name); //initially this is used to execute pseudoSql on the data
			assembler = new assembler(assemblerSpecs.params);
			return assembler;
		} else {
			var assembler = require('assemblers/concatenate'); //default
			assembler = new assembler({});
			return assembler;
		}
	}

	this.getSchemaName = function(fileName) {
		fileName = fileName.replace(/\..*$/, '');

		var localName = qtools.getIndexByValue(self.dataSource.schemaSourceNameMapping, fileName),
			definedName = qtools.getIndexByValue(self.definitions, fileName, 'fileName'),
			finalName = localName ? localName : definedName;
		return finalName;



	}

	this.getDefinition = function(definitionName) {
		
		if (typeof(self.definitions[definitionName])=='undefined'){
			return;
		}

		var outObj = {};
		var hoistedPropertyName = 'maps',
			destName = 'targetMap';
		if (typeof (self.definitions[definitionName][hoistedPropertyName]) != 'undefined' && typeof (self.definitions[definitionName][hoistedPropertyName][this.target]) != 'undefined') {
			outObj[destName] = self.definitions[definitionName][hoistedPropertyName][this.target];
		} else {
			outObj[destName] = {};
		}

		var hoistedPropertyName = 'assembler',
			destName = 'targetAssembler';
		if (typeof (self.definitions[definitionName][hoistedPropertyName]) != 'undefined' && typeof (self.definitions[definitionName][hoistedPropertyName][this.target]) != 'undefined') {

			var assemblerSpecs = self.definitions[definitionName][hoistedPropertyName][this.target],
				fileName = __dirname + '/node_modules/assemblers/' + assemblerSpecs.name + '/' + assemblerSpecs.name + '.js';
			if (fs.existsSync(fileName)) {
				var assembler = require(fileName);
			} else if (fs.existsSync(assemblerSpecs.name)) {
				var assembler = require(assemblerSpecs.name);
			} else {

				qtools.die({
					msg: "assembler module does not exist: " + assemblerSpecs.name,
					definition: self.definitions[definitionName]
				});
			}
			assembler = new assembler(assemblerSpecs.params);

			outObj[destName] = assembler;
		} else {
			outObj[destName] = {};
		}

		var hoistedPropertyName = 'translation',
			destName = 'targetTranslation';
		if (typeof (self.definitions[definitionName][hoistedPropertyName]) != 'undefined' && typeof (self.definitions[definitionName][hoistedPropertyName][this.target]) != 'undefined') {
			outObj[destName] = self.definitions[definitionName][hoistedPropertyName][this.target];
		} else {
			outObj[destName] = {};
		}


		outObj.fileDataFormat = self.definitions[definitionName].fileDataFormat;
		outObj.fieldList = qtools.clone(self.definitions[definitionName].fieldList);
		outObj.sourceFieldList = qtools.clone(self.definitions[definitionName].fieldList);

		if (self.simpleEntityWithFieldHeader) {
			outObj.fieldList = "simpleEntityWithFieldHeader"
		}
		;



		return outObj;
	}

	this.setMainDefinitionName = function(definitionName) {
		self.mainDefinitionName = definitionName;
	}

	this.flatSpecs = function() {
		if (self.definitions[self.mainDefinitionName]) {
			var fieldList = self.definitions[self.mainDefinitionName].fieldList;
			return {
				fieldList: fieldList,
				includeHeaderRow: false
			};
		} else {
			return {
				fieldList: {},
				includeHeaderRow: false
			};
		}
	}


	this.listDefinitions = function(simple) {
		//not used by app; occasionally easier to list this than search the file system
		simple = simple ? simple : false;

		var outList = [];
		for (var i in self.definitions) {
			var element = self.definitions[i];
			if (simple) {
				outList.push(i);
			} else {
				var item = {};
				item.name = i;

				if (element.componentSchemaList) {
					item.componentSchemaList = element.componentSchemaList.join(', ').replace(/, $/, '');
				}
				if (element.fieldList) {
					item.fieldList = element.fieldList.join(', ').replace(/, $/, '');
				}
				outList.push(item);
			}

		}
		return outList;
	}


	this.forceEvent = forceEvent;
	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;





