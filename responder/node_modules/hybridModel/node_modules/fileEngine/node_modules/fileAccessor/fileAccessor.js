
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util'),
	fs = require('fs');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;
	this.ping = qtools.ping;


	qtools.validateProperties({
		subject: args,
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'lookupControl',
				optional: false
			},
			{
				name: 'dataSource',
				optional: false
			}
		]
	});


	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};


	//LOCAL FUNCTIONS ====================================

	var getList = function(path, callback) {
		fs.readdir(path, callback);
	}

	var getFile = function(path, callback) {
		fs.readFile(path, callback);
	}

	var removeDottedDirs = function(list) {
		var outArray = [];
		for (var i = 0, len = list.length; i < len; i++) {
			var element = list[i];
			if (element.substring(0, 1) == '.') {
				continue;
			}
			outArray.push(element);
		}
		return outArray;
	}

	var goGetIt = function() {
		var basePath = args.dataSource.location,
			queryInfo = args.queryInfo,
			rawResult;

		var lookupControl = self.lookupControl;

		if (lookupControl.type == 'data') {


			var fileCallback = function(err, result) {

				if (err) {
					self.emit('gotBadData', err);
				} else {
					result = result
					.toString("utf8", 0, result.length)
					.replace(/(\r\n)|(\n\r)|(\r)/g, "\n");

					var processedResult = result.split("\n"),
						finalDataList = [];

					for (var i = 0, len = processedResult.length; i < len; i++) {
						var element = processedResult[i],
							rowArray = element.split("\t");

						if (element.length) {
							//don't want empty rows
							finalDataList.push(rowArray);
						}
					}

					self.emit('gotRawData', finalDataList, lookupControl.finalValue);
				}
			}
			var path = basePath + lookupControl.dataLocation + '_File.txt';
			getFile(path, fileCallback);

		} else {


			var dirCallback = function(err, result) {
				if (err) {
					self.emit('gotBadData', err);
				} else {
					result = removeDottedDirs(result);
					self.emit('gotRawList', result);
				}
			}
			var path = basePath + lookupControl.dataLocation
			getList(path, dirCallback);
		}

	}

	//METHODS AND PROPERTIES ====================================

	this.getRawData = function(callback) {

		self.on('gotRawData', function(finalDataList, schemaName) {
			callback('', {
				status: 1,
				type: schemaName,
				data: finalDataList,
				meta: qtools.getMetaData()
			},
			self.serverProfile.converterName
			);
		});

		self.on('gotRawList', function(finalDataList) {
			callback('', {
				status: 1,
				type: 'list',
				data: finalDataList,
				meta: qtools.getMetaData()
			}, self.serverProfile.converterName);
		});

		self.on('gotBadData', function(err) {
			err.meta=qtools.mergeMetaData({evidence:err.evidence});
			delete err.evidence;
			callback(err);
		});


		goGetIt();
	};

	//INITIALIZATION ====================================



	var serverProfilePath = __dirname + '/../../../serverProfiles/';

	try {
		this.serverProfile = require(serverProfilePath + self.dataSource.serverProfile);
	} catch (e) {
		this.serverProfile = require(serverProfilePath + 'defaultServerProfile/');
	}

	this.serverProfile = new this.serverProfile();




	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;













