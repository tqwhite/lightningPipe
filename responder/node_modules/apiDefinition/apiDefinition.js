'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;

	qtools.validateProperties({
		subject: args,
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'version',
				optional: false
			},
			{
				name: 'name',
				optional: false
			}
		]
	});

	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};


	//LOCAL FUNCTIONS ====================================

	var extractFields = function(inString) {
		return inString.replace(/\/$/, '').split('/');
	}

	var checkQuery1 = function(callback) {
		var newQuery = self.queryInfo;

		for (var i = 0, len = newQuery.length; i < len; i++) {
			var element = newQuery[i].name;

			if (self.validSegmentNames.indexOf(element) == -1) {
				if (typeof (outList) == 'undefined') {
					var outList = [];
				}
				outList.push(element);
			}

		}
		if (typeof (outList) == 'undefined') {

			var badSequence = false;
			for (var i = 0, len = newQuery.length; i < len; i++) {
				var element = newQuery[i].name,
					comparison = self.validSegmentNames[i];
				if (element != comparison) {
					badSequence = true;
				}
			}
			if (badSequence) {
				callback({
					data: {
						message: 'Bad URI. Segments are out of sequence. Use: ' + self.validSegmentNames.join('/value/') + '/value',
						evidence: self.originalQueryString
					},
					meta: qtools.getMetaData()
				}, '');

			} else {
				callback('', {});
			}
		} else {
			callback({
				data: {
					message: 'Bad segment(s) in URI ('+outList.join(' ')+')',
					evidence: outList
				},
				meta: qtools.getMetaData()
			}, '');
		}
	}

	//PARSERS ====================================


	this.parsers = {};
	this.parsers.uff = {};

	this.parsers.uff['1.0'] = function(uriPath) {
		/*
		Note to self: fileAccessor, the thing that uses the result of this, loops over
		the queryInfo, assuming it's in the right order (after validating with checkQuery()).
		That means that the sequence in validSegmentNames is significant. 
		
		I think that I should make it so that fileAccessor grabs this stuff and sequences
		it to match its file system layout before it builds a path.
		
		That means that the URI probably should not care what order the values arrive in.
		*/

		self.validSegmentNames = ['districts', 'schools', 'segments']; //the sequence is important
		self.originalQueryString = uriPath;

		var queryInfo = [];
		var list = extractFields(uriPath);
		for (var i = 0, len = list.length; i < len; i = i + 2) {
			var operand = list[i + 1];

			queryInfo.push({
				name: list[i],
				value: operand ? operand : 'list'
			});

			if (!operand) {
				break;
			}

		}
		
		this.queryInfo = queryInfo;
		self.checkQuery=checkQuery1; //ps, the client uses this to check the query when it has fabricated the callback
		
		self.accessorList={};
		
		self.accessorList.file='fileAccessor';
		
		self.accessorList.mssql='mssqlAccessor';
		
		return queryInfo;

	}


	//METHODS AND PROPERTIES ====================================


	this.parse = self.parsers[self.name][self.version];




	//INITIALIZATION ====================================



	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;


